import { Callout } from 'nextra/components'
import { Tabs, Tab } from 'nextra-theme-docs'
import Cards from '@/components/Cards/Cards'
import { languages } from '@/data/languages'
import Image from 'next/image'

<Callout type="info"> Note: The feature to execute code within your Promptfile file is currently experimental. We are diligently working on enhancing its syntax and usage. </Callout>

## Languages Currently Supported

<Cards children={languages} />

## Executable Code


Promptfile features an `<Code>{:glass}` element that enables you to write code to be executed prior to evaluating the prompt. This is particularly helpful for tasks such as data retrieval, performing calculations, or executing any other code that needs to be run before prompting the large language model (LLM).

```prompt copy filename="example.glass"
<Code>
const myMessage = "This is code! You can define which language you want in the frontmatter or adjust your default language in your VSCode settings."
</Code>


<System>
@{myMessage}
</System>

<Request model="gpt-3.5-turbo" />
```

## Event Handling: onResponse

Similar to React, Promptfile incorporates an event handling system. The onResponse function is triggered when a request has been completed, and the response is received. This is especially useful for taking actions after a response, such as updating the state of the Promptfile file.

Here's an example of a request utilizing the onResponse function. To access the response from the request, use the .message attribute of the response object:

```prompt copy filename="onResponse.glass"
<Request model="gpt-4" onResponse = {response => {
    someFunction(response.message)
}} />
```

## State Management: useState

Similar to React's [`useState`](https://react.dev/reference/react/useState) hook, which adds state variables to components, Promptfile also supports `useState`. To declare a state variable in Promptfile, follow this example:

```prompt copy filename="useState.glass"
<Code>
const [stateVariable, setStateVariable] = useState(initialValue)
</Code>
```
You can then update the state variable by calling the `setStateVariable` function. This will add the updated state variable to the Promptfile file.
```prompt copy filename="updatingState.glass"
<Code>
const [stateVariable, setStateVariable] = useState(initialValue)
setStateVariable(newValue)
</Code>
```

## Putting it all together

Below is an example showcasing the combined use of onResponse and useState in a Promptfile file:

```prompt copy filename="events_state.glass"
<Code>
// This works just like `useState` in React
const [lastMessageText, setLastMessageText] = useState('')
const [numResponses, setNumResponses] = useState(0)
</Code>

<System>
You are FunnyGPT. Respond to the user with a message that's maximally likely to make them laugh.
</System>

<User>
can you tell me a joke about kittens?
</User>

<Request
  model="gpt-3.5-turbo"
  onResponse={response => {
    setNumResponses(numResponses + 1)
    setLastMessageText(response.message)
  }}
/>
```

In the example provided earlier, after executing the onResponse function and updating the state variable responseMessage, the Promptfile file will display the updated state.

```prompt copy filename="events_state.glass"
<State>
{
  "lastMessageText": "Sure, here's one: \n\nWhy did the kitten join Tinder? \nTo find her purr-fect match!",
  "numResponses": 1
}
</State>


<Code>
// This works just like `useState` in React
const [lastMessageText, setLastMessageText] = useState('')
const [numResponses, setNumResponses] = useState(0)
</Code>


<System>
You are FunnyGPT. Respond to the user with a message that's maximally likely to make them laugh.
</System>


<User>
can you tell me a joke about kittens?
</User>


<Assistant model="gpt-3.5-turbo" temperature={1}>
Sure, here's one:
Why did the kitten join Tinder?
To find her purr-fect match!
</Assistant>
```
