/* eslint-disable */
// THIS FILE WAS GENERATED BY GLASS -- DO NOT EDIT!

import { z } from 'zod'
import * as glasslib from '@glass-lang/glasslib'
const useState = glasslib.useState

export function getA006A6Co66Tstp0Xt66632WkzqdPrompt() {
  function getTestData() {
    return [
      {
        model: 'model test value',
        error: 'error test value',
      },
    ].map(glass_example => ({ ...{}, ...glass_example }))
  }

  const compile = async (opt: {
    args: {
      vscode: string
      model: string
      let: string
      numBlocks: string
      newBlocks: string
      activeEditor: string
      selection: string
      console: string
      error: string
    }
  }) => {
    const GLASS_STATE = {}
    const { vscode, model, let, numBlocks, newBlocks, activeEditor, selection, console, error } = opt.args

    const GLASSVAR = {}
    const TEMPLATE = `

<Test>
return [{
  model: "model test value",
error: "error test value"
}]
</Test>


<System>
You are ChatGPT. Browsing: disabled.
</System>


<User>
I have the following code:

\`\`\`ts
export async function runGlassExtension(document: vscode.TextDocument, outputChannel: vscode.OutputChannel) {
  // set document to active if it isn't already
  const activeEditor = vscode.window.activeTextEditor
  if (!activeEditor || activeEditor.document.uri.fsPath !== document.uri.fsPath) {
    await vscode.window.showTextDocument(document)
  }
  const session = document.uri.fsPath
  const glass = document.getText()
  const frontmatter = parseFrontmatterFromGlass(glass)
  if (!frontmatter) {
    await vscode.window.showErrorMessage('Unable to parse frontmatter from Glass file')
    return
  }
  const elements = parseGlassBlocksRecursive(glass)
  const requestElement = elements.find(element => element.tag === 'Request')
  const model = requestElement?.attrs?.find((attr: any) => attr.name === 'model')?.stringValue
  const languageModel = LANGUAGE_MODELS.find(m => m.name === model)
  if (!languageModel) {
    await vscode.window.showErrorMessage(\`Unable to find model ${model}\`)
    return
  }
  switch (languageModel.creator) {
    case LanguageModelCreator.anthropic:
      const anthropicKey = getAnthropicKey()
      if (anthropicKey == null || anthropicKey === '') {
        await vscode.commands.executeCommand('workbench.action.openSettings', 'glass.anthropicKey')
        await vscode.window.showErrorMessage('Add Anthropic API key to run Glass files.')
        return
      }
      break
    case LanguageModelCreator.openai:
      const openaiKey = getOpenaiKey()
      if (openaiKey == null || openaiKey === '') {
        await vscode.commands.executeCommand('workbench.action.openSettings', 'glass.openaiKey')
        await vscode.window.showErrorMessage('Add OpenAI API key to run Glass files.')
        return
      }
      break
  }

  // Ensure a workspace is opened
  if (!vscode.workspace.workspaceFolders) {
    await vscode.window.showErrorMessage('No workspace opened')
    return
  }

  try {
    let numBlocks = parseGlassTranscriptBlocks(glass).length
    const resp = await executeGlassFile(session, outputChannel, document, glass, {}, async progress => {
      const newBlocks = parseGlassTranscriptBlocks(progress.nextGlassfile)
      if (newBlocks.length > numBlocks) {
        numBlocks = newBlocks.length
        // make a document edit to update the document with progress.nextGlassfile
        const edit = new vscode.WorkspaceEdit()
        const range = new vscode.Range(0, 0, document.lineCount, 0)
        const withFrontmatter = addFrontmatter(
          progress.nextGlassfile,
          frontmatter.file,
          frontmatter.session,
          frontmatter.timestamp
        )
        edit.replace(document.uri, range, withFrontmatter)
        await vscode.workspace.applyEdit(edit)
        scrollToBottom(document)
        return true
      }

      const currentGlass = document.getText()
      const blocks = parseGlassTranscriptBlocks(currentGlass)
      const streamingBlock = blocks.find(block => (block.child?.content ?? '').includes('█'))
      if (!streamingBlock || !progress.response || !streamingBlock.child) {
        return false
      }
      const edit = new vscode.WorkspaceEdit()
      const range = new vscode.Range(
        document.positionAt(streamingBlock.child.position.start.offset),
        document.positionAt(streamingBlock.child.position.end.offset)
      )
      edit.replace(document.uri, range, progress.response)
      await vscode.workspace.applyEdit(edit)
      scrollToBottom(document)
      return true
    })
    if (!document.getText().includes('█')) {
      return
    }

    // remove the █ character via document
    const edit = new vscode.WorkspaceEdit()
    const location = document.getText().indexOf('█')
    edit.delete(document.uri, new vscode.Range(document.positionAt(location), document.positionAt(location + 1)))
    if (resp.continued) {
      await vscode.workspace.applyEdit(edit)
      scrollToBottom(document)
      await runGlassExtension(document, outputChannel)
    } else {
      const addToGlassfile = \`


<User>

</User>


<Request model="${model}" />\`
      // make a document edit to update the document with progress.nextGlassfile
      const range = new vscode.Range(0, 0, document.lineCount, 0)
      edit.insert(document.uri, range.end, addToGlassfile)
      await vscode.workspace.applyEdit(edit)
      await document.save()
      scrollToBottom(document)
      const finalGlassfile = document.getText()
      const lines = finalGlassfile.split('\n')
      const position = new vscode.Position(lines.length - 5, 0)
      const selection = new vscode.Selection(position, position)
      const activeEditor = vscode.window.activeTextEditor
      if (activeEditor && activeEditor.document.uri.fsPath === document.uri.fsPath) {
        activeEditor.selection = selection
        activeEditor.revealRange(selection)
      }
    }
  } catch (error) {
    console.error(error)
    void vscode.window.showErrorMessage(\`ERROR: ${error}\`)
  }
}
\`\`\`

I've noticed that this code doesn't activate the cursor in the document after it is run. this may be because the running document isn't always active when it's run. how can i fix this?
</User>


<Request model="gpt-4" />`
    return {
      fileName: 'A006A6CO66TSTP0XT66632WKZQD.glass',
      interpolatedDoc: TEMPLATE,
      originalDoc:
        "---\nfile: brainstorm.glass\nsession: A006A6CO66TSTP0XT66632WKZQD\ntimestamp: 2023-06-17T19:05:27.149Z\n---\n\n\n<Test>\nreturn [{\n  model: \"model test value\",\nerror: \"error test value\"\n}]\n</Test>\n\n\n<System>\nYou are ChatGPT. Browsing: disabled.\n</System>\n\n\n<User>\nI have the following code:\n\n```ts\nexport async function runGlassExtension(document: vscode.TextDocument, outputChannel: vscode.OutputChannel) {\n  // set document to active if it isn't already\n  const activeEditor = vscode.window.activeTextEditor\n  if (!activeEditor || activeEditor.document.uri.fsPath !== document.uri.fsPath) {\n    await vscode.window.showTextDocument(document)\n  }\n  const session = document.uri.fsPath\n  const glass = document.getText()\n  const frontmatter = parseFrontmatterFromGlass(glass)\n  if (!frontmatter) {\n    await vscode.window.showErrorMessage('Unable to parse frontmatter from Glass file')\n    return\n  }\n  const elements = parseGlassBlocksRecursive(glass)\n  const requestElement = elements.find(element => element.tag === 'Request')\n  const model = requestElement?.attrs?.find((attr: any) => attr.name === 'model')?.stringValue\n  const languageModel = LANGUAGE_MODELS.find(m => m.name === model)\n  if (!languageModel) {\n    await vscode.window.showErrorMessage(`Unable to find model ${model}`)\n    return\n  }\n  switch (languageModel.creator) {\n    case LanguageModelCreator.anthropic:\n      const anthropicKey = getAnthropicKey()\n      if (anthropicKey == null || anthropicKey === '') {\n        await vscode.commands.executeCommand('workbench.action.openSettings', 'glass.anthropicKey')\n        await vscode.window.showErrorMessage('Add Anthropic API key to run Glass files.')\n        return\n      }\n      break\n    case LanguageModelCreator.openai:\n      const openaiKey = getOpenaiKey()\n      if (openaiKey == null || openaiKey === '') {\n        await vscode.commands.executeCommand('workbench.action.openSettings', 'glass.openaiKey')\n        await vscode.window.showErrorMessage('Add OpenAI API key to run Glass files.')\n        return\n      }\n      break\n  }\n\n  // Ensure a workspace is opened\n  if (!vscode.workspace.workspaceFolders) {\n    await vscode.window.showErrorMessage('No workspace opened')\n    return\n  }\n\n  try {\n    let numBlocks = parseGlassTranscriptBlocks(glass).length\n    const resp = await executeGlassFile(session, outputChannel, document, glass, {}, async progress => {\n      const newBlocks = parseGlassTranscriptBlocks(progress.nextGlassfile)\n      if (newBlocks.length > numBlocks) {\n        numBlocks = newBlocks.length\n        // make a document edit to update the document with progress.nextGlassfile\n        const edit = new vscode.WorkspaceEdit()\n        const range = new vscode.Range(0, 0, document.lineCount, 0)\n        const withFrontmatter = addFrontmatter(\n          progress.nextGlassfile,\n          frontmatter.file,\n          frontmatter.session,\n          frontmatter.timestamp\n        )\n        edit.replace(document.uri, range, withFrontmatter)\n        await vscode.workspace.applyEdit(edit)\n        scrollToBottom(document)\n        return true\n      }\n\n      const currentGlass = document.getText()\n      const blocks = parseGlassTranscriptBlocks(currentGlass)\n      const streamingBlock = blocks.find(block => (block.child?.content ?? '').includes('█'))\n      if (!streamingBlock || !progress.response || !streamingBlock.child) {\n        return false\n      }\n      const edit = new vscode.WorkspaceEdit()\n      const range = new vscode.Range(\n        document.positionAt(streamingBlock.child.position.start.offset),\n        document.positionAt(streamingBlock.child.position.end.offset)\n      )\n      edit.replace(document.uri, range, progress.response)\n      await vscode.workspace.applyEdit(edit)\n      scrollToBottom(document)\n      return true\n    })\n    if (!document.getText().includes('█')) {\n      return\n    }\n\n    // remove the █ character via document\n    const edit = new vscode.WorkspaceEdit()\n    const location = document.getText().indexOf('█')\n    edit.delete(document.uri, new vscode.Range(document.positionAt(location), document.positionAt(location + 1)))\n    if (resp.continued) {\n      await vscode.workspace.applyEdit(edit)\n      scrollToBottom(document)\n      await runGlassExtension(document, outputChannel)\n    } else {\n      const addToGlassfile = `\n\n\n<User>\n\n</User>\n\n\n<Request model=\"${model}\" />`\n      // make a document edit to update the document with progress.nextGlassfile\n      const range = new vscode.Range(0, 0, document.lineCount, 0)\n      edit.insert(document.uri, range.end, addToGlassfile)\n      await vscode.workspace.applyEdit(edit)\n      await document.save()\n      scrollToBottom(document)\n      const finalGlassfile = document.getText()\n      const lines = finalGlassfile.split('\\n')\n      const position = new vscode.Position(lines.length - 5, 0)\n      const selection = new vscode.Selection(position, position)\n      const activeEditor = vscode.window.activeTextEditor\n      if (activeEditor && activeEditor.document.uri.fsPath === document.uri.fsPath) {\n        activeEditor.selection = selection\n        activeEditor.revealRange(selection)\n      }\n    }\n  } catch (error) {\n    console.error(error)\n    void vscode.window.showErrorMessage(`ERROR: ${error}`)\n  }\n}\n```\n\nI've noticed that this code doesn't activate the cursor in the document after it is run. this may be because the running document isn't always active when it's run. how can i fix this?\n</User>\n\n\n<Request model=\"gpt-4\" />",
      state: GLASS_STATE,
      interpolationArgs: opt.args || {},
      requestBlocks: [
        {
          model: 'gpt-4',
          onResponse: undefined,
          temperature: undefined,
          maxTokens: undefined,
          stopSequence: undefined,
        },
      ],
      functions: [],
    }
  }

  const run = async (options: {
    args: {
      vscode: string
      model: string
      let: string
      numBlocks: string
      newBlocks: string
      activeEditor: string
      selection: string
      console: string
      error: string
    }
    transcriptTokenCounter?: {
      countTokens: (str: string, model: string) => number
      maxTokens: (model: string) => number
      reserveCount?: number
    }
    openaiKey?: string
    anthropicKey?: string
    progress?: (data: { nextGlassfile: string; response: string }) => void
  }) => {
    const c = await compile({ args: options.args || {} })
    return await glasslib.runGlassTranspilerOutput(c, options)
  }

  return { getTestData, compile, run }
}

export const Glass = {
  a006A6Co66Tstp0Xt66632WkzqdGlass: getA006A6Co66Tstp0Xt66632WkzqdPrompt,
}

context.response = getA006A6Co66Tstp0Xt66632WkzqdPrompt()